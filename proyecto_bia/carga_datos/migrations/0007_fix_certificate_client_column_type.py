# Generated by Django 5.1.7 on 2025-08-24 16:07
# carga_datos/migrations/0007_fix_certificate_client_column_type.py

from django.db import migrations

# 1) Quitar FK previa sobre client_id
DROP_FK_SQL = r"""
DO $$
DECLARE
    fk_name text;
BEGIN
    IF to_regclass('public.certificate') IS NULL THEN
        RETURN;
    END IF;

    SELECT conname INTO fk_name
    FROM pg_constraint
    WHERE conrelid = 'public.certificate'::regclass
      AND contype = 'f'
      AND array_position(conkey, (
          SELECT attnum
          FROM pg_attribute
          WHERE attrelid = 'public.certificate'::regclass
            AND attname  = 'client_id'
      )) IS NOT NULL;

    IF fk_name IS NOT NULL THEN
        EXECUTE format('ALTER TABLE public.certificate DROP CONSTRAINT %I', fk_name);
    END IF;
END$$;
"""

# 2) Quitar cualquier UNIQUE constraint sobre client_id (evita el error al dropear el índice)
DROP_UNIQUES_ON_CLIENT_ID_SQL = r"""
DO $$
DECLARE
    cons RECORD;
BEGIN
    IF to_regclass('public.certificate') IS NULL THEN
        RETURN;
    END IF;

    FOR cons IN
        SELECT conname
        FROM pg_constraint
        WHERE conrelid = 'public.certificate'::regclass
          AND contype = 'u'
          AND array_position(conkey, (
              SELECT attnum
              FROM pg_attribute
              WHERE attrelid = 'public.certificate'::regclass
                AND attname  = 'client_id'
          )) IS NOT NULL
    LOOP
        EXECUTE format('ALTER TABLE public.certificate DROP CONSTRAINT %I', cons.conname);
    END LOOP;
END$$;
"""

# 3) Dropear cualquier índice remanente sobre client_id (incluye varchar_pattern_ops)
DROP_INDEXES_ON_CLIENT_ID_SQL = r"""
DO $$
DECLARE
    idx RECORD;
BEGIN
    IF to_regclass('public.certificate') IS NULL THEN
        RETURN;
    END IF;

    FOR idx IN
        SELECT i.relname AS index_name
        FROM pg_class t
        JOIN pg_index x     ON x.indrelid = t.oid
        JOIN pg_class i     ON i.oid = x.indexrelid
        JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(x.indkey)
        WHERE t.oid = 'public.certificate'::regclass
          AND a.attname = 'client_id'
    LOOP
        EXECUTE format('DROP INDEX IF EXISTS %I', idx.index_name);
    END LOOP;
END$$;
"""

# 4) Backfill: si client_id tenía id_pago_unico (texto), mapearlo al id numérico
BACKFILL_TO_ID_SQL = r"""
DO $$
BEGIN
    IF to_regclass('public.certificate') IS NULL OR to_regclass('public.db_bia') IS NULL THEN
        RETURN;
    END IF;

    UPDATE public.certificate c
    SET client_id = b.id::text
    FROM public.db_bia b
    WHERE c.client_id IS NOT NULL
      AND c.client_id <> ''
      AND c.client_id::text = b.id_pago_unico::text;

    -- Cualquier residuo no numérico -> NULL (para no fallar en el casteo)
    UPDATE public.certificate
    SET client_id = NULL
    WHERE client_id IS NOT NULL
      AND client_id !~ '^\d+$';
END$$;
"""

# 5) Cambiar tipo a BIGINT
ALTER_TO_BIGINT_SQL = r"""
DO $$
BEGIN
    IF to_regclass('public.certificate') IS NULL THEN
        RETURN;
    END IF;

    ALTER TABLE public.certificate
    ALTER COLUMN client_id TYPE bigint
    USING NULLIF(client_id, '')::bigint;
END$$;
"""

# 6) Volver a imponer unicidad (propio del OneToOne)
ADD_UNIQUE_SQL = r"""
DO $$
BEGIN
    IF to_regclass('public.certificate') IS NULL THEN
        RETURN;
    END IF;

    BEGIN
        ALTER TABLE public.certificate
        ADD CONSTRAINT certificate_client_id_key UNIQUE (client_id);
    EXCEPTION WHEN duplicate_object THEN
        NULL;
    END;
END$$;
"""

# 7) Volver a crear FK hacia db_bia(id)
ADD_FK_SQL = r"""
DO $$
BEGIN
    IF to_regclass('public.certificate') IS NULL OR to_regclass('public.db_bia') IS NULL THEN
        RETURN;
    END IF;

    BEGIN
        ALTER TABLE public.certificate
        ADD CONSTRAINT certificate_client_id_fk
        FOREIGN KEY (client_id) REFERENCES public.db_bia(id)
        ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;
    EXCEPTION WHEN duplicate_object THEN
        NULL;
    END;
END$$;
"""

class Migration(migrations.Migration):
    # *** DEJÁ ESTAS DEPENDENCIAS COMO LAS GENERÓ DJANGO ***
    dependencies = [
        ('carga_datos', '0006_basededatosbia_creditos_and_more'),
    ]

    operations = [
        migrations.RunSQL(DROP_FK_SQL, reverse_sql=migrations.RunSQL.noop),
        migrations.RunSQL(DROP_UNIQUES_ON_CLIENT_ID_SQL, reverse_sql=migrations.RunSQL.noop),
        migrations.RunSQL(DROP_INDEXES_ON_CLIENT_ID_SQL, reverse_sql=migrations.RunSQL.noop),
        migrations.RunSQL(BACKFILL_TO_ID_SQL, reverse_sql=migrations.RunSQL.noop),
        migrations.RunSQL(ALTER_TO_BIGINT_SQL, reverse_sql=migrations.RunSQL.noop),
        migrations.RunSQL(ADD_UNIQUE_SQL, reverse_sql=migrations.RunSQL.noop),
        migrations.RunSQL(
            ADD_FK_SQL,
            reverse_sql="""
                DO $$
                BEGIN
                    IF to_regclass('public.certificate') IS NULL THEN
                        RETURN;
                    END IF;
                    ALTER TABLE public.certificate
                    DROP CONSTRAINT IF EXISTS certificate_client_id_fk;
                END$$;
            """
        ),
    ]
